#include "SpringDamper.h"

// Constructor: Initializes the spring-damper system with two particles, spring constant, damping constant, and rest length.
SpringDamper::SpringDamper(Particle* _P1, Particle* _P2, float* _SpringConst, float* _DampingConst, float* _RestLength)
{
    P1 = _P1; // First particle connected by the spring-damper
    P2 = _P2; // Second particle connected by the spring-damper

    SpringConst = _SpringConst; // Pointer to the spring constant (stiffness of the spring)
    DampingConst = _DampingConst; // Pointer to the damping constant (resistance factor)
    RestLength = _RestLength; // Pointer to the rest length of the spring (natural length without any forces applied)

    // Calculate the initial direction vector from P1 to P2.
    // This is used to calculate forces applied to the particles.
    prevDir = P2->GetPosition() - P1->GetPosition();
}

// Computes and applies the forces generated by the spring and damper to both particles.
void SpringDamper::ComputeForce()
{
    // Calculate the current direction vector from P1 to P2 and its length.
    glm::vec3 dir = P2->GetPosition() - P1->GetPosition();
    float currLength = glm::length(dir);

    // Normalize the direction vector if its length is significant.
    if (currLength > EPSILON)
    {
        dir = glm::normalize(dir);
        prevDir = dir; // Update the previous direction for future use.
    }
    else
    {
        dir = glm::vec3(0.0f); // Reset direction if too small.
        currLength = 0.0f; // Avoid division by zero in subsequent calculations.
    }

    // Calculate the force generated by the spring according to Hooke's Law: F = -k * (x - l)
    // where k is the spring constant, x is the current length, and l is the rest length.
    glm::vec3 f_spring = -(*SpringConst) * ((*RestLength) - currLength) * dir;

    // If the spring force is negligible, reset it to avoid unnecessary calculations.
    if (f_spring.length() < EPSILON) f_spring = glm::vec3(0.0f);

    // Calculate the damping force based on the relative velocity of the two particles along the direction of the spring.
    // F_damping = -c * v, where c is the damping constant and v is the relative velocity along the spring's direction.
    float v = glm::dot(P1->GetVelocity() - P2->GetVelocity(), dir);
    glm::vec3 f_damper = -(*DampingConst) * v * dir;

    // If the damping force is negligible, reset it to avoid unnecessary calculations.
    if (f_damper.length() < EPSILON) f_damper = glm::vec3(0.0f);

    // Apply the combined spring and damping forces to particle P1.
    P1->ApplyForce(f_spring + f_damper);
    // Apply the opposite force to particle P2 to maintain Newton's third law: For every action, there is an equal and opposite reaction.
    P2->ApplyForce(-f_spring - f_damper);
}
